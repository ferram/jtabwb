/*******************************************************************************
 * Copyright (C) 2013, 2016 Mauro Ferrari This program is free software; you can
 * redistribute it and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation; either version 3 of the
 * License, or (at your option) any later version. This program is distributed
 * in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even
 * the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details. You should have received
 * a copy of the GNU General Public License along with this program; if not, see
 * <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package jtabwbx.modal.formula;

import jtabwb.util.CaseNotImplementedImplementationError;
import jtabwb.util.ContractViolationImplementationError;
import jtabwb.util.ImplementationError;
import jtabwbx.modal.basic.ModalConnective;
import jtabwbx.modal.basic.ModalFormulaType;
import jtabwbx.modal.btformula.BTModalFormula;
import jtabwbx.modal.btformula.BTModalFormulaProposition;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;

import org.antlr.v4.runtime.tree.ParseTree;

/**
 * The factory building formulas.
 * 
 * @author Mauro Ferrari
 */
public class ModalFormulaFactory {

  private final Map<String, ModalFormulaProposition> propositions;
  private final Map<AbstractCompoundModalFormula, AbstractCompoundModalFormula> formulaCompounds;
  private final ArrayList<ModalFormula> formulasByIndex;
  private BitSetOfModalFormulas[] formulasByType;
  private BitSetOfModalFormulas generatedFormulas;
  private int formulaCounter;

  boolean translateIff = false; /*
                                 * if true (A <-> B) is built as (A -> B) & (B
                                 * -> A)
                                 */

  /**
   * FALSE is represented by a propositional variable with this name.
   */
  private String FALSE_NAME = "false";

  /**
   * TRUE is represented by a propositional variable with name "true".
   */
  private String TRUE_NAME = "true";

  /**
   * The formula representing the propositional variable FALSE.
   */
  public final ModalFormulaProposition FALSE;

  /**
   * The formula representing the propositional variable TRUE.
   */
  public final ModalFormulaProposition TRUE;

  /**
   * Constructs an instance of the factory using the specified names for true
   * and false representation. Note that the names for true and false must be
   * different, otherwise a {@link ContractViolationImplementationError} is
   * thrown.
   * 
   * @param falseName the name for the false constant.
   * @param trueName the name for the true constant.
   */
  public ModalFormulaFactory(String falseName, String trueName) {
    if (trueName.equals(falseName))
      throw new ContractViolationImplementationError(
          "Names for false and true constants must be different.");
    this.formulaCounter = 0;
    this.propositions = new HashMap<String, ModalFormulaProposition>(100, .5f);
    this.formulaCompounds =
        new HashMap<AbstractCompoundModalFormula, AbstractCompoundModalFormula>(100, .5f);
    this.formulasByIndex = new ArrayList<ModalFormula>(50);
    this.generatedFormulas = new BitSetOfModalFormulas(this);
    this.formulasByType = new BitSetOfModalFormulas[ModalFormulaType.values().length];
    for (int i = 0; i < this.formulasByType.length; i++)
      this.formulasByType[i] = new BitSetOfModalFormulas(this);
    this.FALSE_NAME = falseName;
    this.FALSE = this.buildAtomic(FALSE_NAME);
    this.TRUE_NAME = trueName;
    this.TRUE = this.buildAtomic(TRUE_NAME);
  }

  /**
   * Constructs an instance of the factory using "false" and "true" as names for
   * true and false constants.
   */
  public ModalFormulaFactory() {
    this("false", "true");
  }

  /**
   * The number of distinct formulas generated by this factory.
   * 
   * @return number of distinct formulas generated by this factory
   */
  public int numberOfGeneratedFormulas() {
    return formulaCounter;
  }

  /**
   * Returns a copy of the list of formulas generated by this factory.
   * 
   * @return a copy of the list of formulas generated by this factory.
   */
  @SuppressWarnings("unchecked")
  public ArrayList<ModalFormula> generatedFormulas() {
    return (ArrayList<ModalFormula>) formulasByIndex.clone();
  }

  /**
   * Returns the formula modelling the propositional constant TRUE.
   * 
   * @return the formula representing TRUE.
   */
  public ModalFormulaProposition getTrue() {
    return TRUE;
  }

  /**
   * Returns the formula modelling the propositional constant FALSE.
   * 
   * @return the formula representing FALSE.
   */
  public ModalFormulaProposition getFalse() {
    return FALSE;
  }

  /**
   * Returns the set containing all the generated formulas.
   * 
   * @return the bitset of all generated formulas.
   */
  public BitSetOfModalFormulas getGeneratedFormula() {
    return generatedFormulas;
  }

  /**
   * Returns the set containing all the generated formulas of the specified
   * type.
   * 
   * @param type the type of the formulas to return.
   * @return the bitset of all generated formulas.
   */
  public BitSetOfModalFormulas getGeneratedFormulasOfType(ModalFormulaType type) {
    return formulasByType[type.ordinal()];
  }

  /**
   * Builds the propositional modal formula with the specified name.
   * 
   * @param name the name of the proposition.
   * @return the propositional modal formula.
   */
  public ModalFormulaProposition buildAtomic(String name) {
    ModalFormulaProposition newProp = propositions.get(name);
    if (newProp == null) {
      newProp =
          new ModalFormulaProposition(this, name, name.equals(TRUE_NAME), name.equals(FALSE_NAME));
      newProp.size = 1;
      propositions.put(name, newProp);
      newProp.setIndex(formulaCounter++);
      formulasByIndex.add(newProp);
      this.generatedFormulas.add(newProp);
      this.formulasByType[newProp.getFormulaType().ordinal()].add(newProp);
    }
    return newProp;
  }

  /**
   * Builds the formula having the specified logical constant as main connective
   * and the specified subformulas as direct subformulas.
   * 
   * @param mainConnective the main connective (a logical constant).
   * @param subFormulas the direct subformulas.
   * @return the corresponding compound formula.
   */
  public ModalFormula buildCompound(ModalConnective mainConnective, ModalFormula... subFormulas) {

    if (mainConnective.arity() != subFormulas.length)
      throw new ImplementationError("Wrong numeber of arguments: arity " + mainConnective.arity()
          + ", subformulas " + subFormulas.length);

    AbstractCompoundModalFormula newFormula;
    switch (mainConnective) {
    case NOT:
      newFormula = new ModalFormulaNot(this, subFormulas[0]);
      break;
    case BOX:
      newFormula = new ModalFormulaBOX(this, subFormulas[0]);
      break;
    case DIA:
      newFormula = new ModalFormulaDIA(this, subFormulas[0]);
      break;
    case IMPLIES:
      newFormula = new ModalFormulaImplies(this, subFormulas[0], subFormulas[1]);
      break;
    case EQ:
      if (translateIff) {
        ModalFormula leftToRight =
            buildCompound(ModalConnective.IMPLIES, subFormulas[0], subFormulas[1]);
        ModalFormula rightToLeft =
            buildCompound(ModalConnective.IMPLIES, subFormulas[1], subFormulas[0]);
        newFormula = new ModalFormulaAnd(this, leftToRight, rightToLeft);
      } else
        newFormula = new ModalFormulaIff(this, subFormulas[0], subFormulas[1]);
      break;
    case AND:
      newFormula = new ModalFormulaAnd(this, subFormulas[0], subFormulas[1]);
      break;
    case OR:
      newFormula = new ModalFormulaOr(this, subFormulas[0], subFormulas[1]);
      break;
    default:
      throw new CaseNotImplementedImplementationError(mainConnective.getName());
    }

    return getCanonicalFormula(newFormula);
  }

  private AbstractCompoundModalFormula getCanonicalFormula(AbstractCompoundModalFormula newFormula) {
    AbstractCompoundModalFormula canonicalFormula = formulaCompounds.get(newFormula);
    if (canonicalFormula == null) {
      formulaCompounds.put(newFormula, newFormula);
      canonicalFormula = newFormula;
      canonicalFormula.setIndex(formulaCounter++);
      formulasByIndex.add(canonicalFormula);
      this.generatedFormulas.add(canonicalFormula);
      this.formulasByType[canonicalFormula.getFormulaType().ordinal()].add(canonicalFormula);
    }
    return canonicalFormula;
  }

  /**
   * Returns the formula with the specified index. 
   * @param index the index of the formula.
   * @return the formula with the specified index.
   */
  public ModalFormula getByIndex(int index) {
    return formulasByIndex.get(index);
  }

  /**
   * Build an instance of the specified {@link ModalFormula} in this factory.
   * 
   * @param wff the formula to build.
   * @return the instance of the formula in this factory.
   */
  public ModalFormula buildFrom(ModalFormula wff) {
    if (wff.isAtomic())
      return buildAtomic(((ModalFormulaProposition) wff).getName());
    else {
      ModalConnective mainConnective = wff.mainConnective();
      switch (mainConnective) {
      case AND:
      case EQ:
      case IMPLIES:
      case OR: {
        ModalFormula left = buildFrom(wff.immediateSubformulas()[0]);
        ModalFormula right = buildFrom(wff.immediateSubformulas()[1]);
        return buildCompound(mainConnective, left, right);
      }
      case NOT:
      case BOX:
      case DIA:
        return buildCompound(mainConnective, buildFrom(wff.immediateSubformulas()[0]));
      default:
        throw new ImplementationError(ImplementationError.CASE_NOT_IMPLEMENTED);
      }
    }
  }

  /**
   * Build an instance of the specified {@link BTModalFormula}.
   * 
   * @param wff the formula to build.
   * @return the instance of the formula in this factory.
   */
  public ModalFormula buildFrom(BTModalFormula wff) {
    if (wff.isAtomic())
      return buildAtomic(((BTModalFormulaProposition) wff).getName());
    else {
      ModalConnective mainConnective = wff.mainConnective();
      ModalFormula translation = null;
      switch (mainConnective) {
      case AND:
      case EQ:
      case IMPLIES:
      case OR: {
        ModalFormula left = buildFrom(wff.immediateSubformulas()[0]);
        ModalFormula right = buildFrom(wff.immediateSubformulas()[1]);
        translation = buildCompound(mainConnective, left, right);
        break;
      }
      case NOT:
      case BOX:
      case DIA:
        translation = buildCompound(mainConnective, buildFrom(wff.immediateSubformulas()[0]));
        break;
      default:
        throw new ImplementationError(ImplementationError.CASE_NOT_IMPLEMENTED);
      }
      return translation;
    }
  }

  /**
   * Build a modal formula from the specified parse-tree.
   * 
   * @param parseTree the parse tree.
   * @return the instance of the modal formula in this factory.
   */
  public ModalFormula buildFrom(ParseTree parseTree) {
    FromParseTreeFormulaBuilder builder = new FromParseTreeFormulaBuilder(this);
    return builder.buildFrom(parseTree);
  }

  /**
   * If <code>b</code> is <code>true</code> equivalences
   * <code>(A &lt;-&gt; B)</code> are built as
   * <code>(A -&gt; B) &amp; (B -&gt; A)</code>.
   * 
   * @param b if <code>true</code> equivalences are translated
   */
  public void setTranslateEquivalences(boolean b) {
    translateIff = b;
  }

  @Override
  public String toString() {
    StringBuffer sb = new StringBuffer();
    sb.append(this.getClass().getName());
    sb.append("propositions: " + propositions.size() + "\n");
    sb.append("compound formulas: " + formulaCompounds.size() + "\n");
    sb.append("List of formulas");
    for (int i = 0; i < formulasByIndex.size(); i++) {
      ModalFormula wff = formulasByIndex.get(i);
      sb.append(wff.getIndex() + "- " + wff.format());
      if (i < formulasByIndex.size() - 1)
        sb.append("\n");
    }

    return sb.toString();
  }

  public String getDescription() {
    return "Modal formula factory";
  }
}
